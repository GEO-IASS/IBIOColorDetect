function validationData = t_colorGaborDetectFindPerformance(rParams,LMPlaneInstanceParams,thresholdParams)
% validationData = t_colorGaborDetectFindPerformance([rParams],[LMPlaneInstanceParams],[thresholdParams])
%
% Classify data generated by
%   t_colorGaborConeCurrentEyeMovementsResponseInstances.
% That tutorial generates multiple noisy instances of responses for color
% Gabors and saves them out.  Here we read the output and use an
% SVM to build a computational observer that gives us percent correct, and
% then do this for multiple contrasts.  The output of this tutorial can
% then be used by
%   t_colorGaborDetectThresholdsOnLMPlane
% to find and plot thresholds.
%
% The intput comes from and the output goes into a place determined by
%   colorGaborDetectOutputDir
% which itself checks for a preference set by
%   ISETColorDetectPreferencesTemplate
% which you may want to edit before running this and other scripts that
% produce substantial output.  The output within the main output directory
% is sorted by directories whose names are computed from parameters.  This
% naming is done in routine
%   paramsToDirName.
%
% See also
%   t_colorGaborConeCurrentEyeMovementsResponseInstances,
%   t_colorGaborDetectIllustrateClassificationBoundary,
%   t_plotGabotDetectThresholdsOnLMPlane.
%
% 7/11/16  npc Wrote it.

%% Clear
ieInit; clear; close all;

%% Fix random number generator so we can validate output exactly
rng(1);

%% Get the parameters we need
%
% t_colorGaborResponseGenerationParams returns a hierarchical struct of
% parameters used by a number of tutorials and functions in this project.
if (nargin < 1 | isempty(rParams))
    rParams = colorGaborResponseParamsGenerate;
    
    % Override some defult parameters
    %
    % Set duration equal to sampling interval to do just one frame.
    rParams.temporalParams.simulationTimeStepSecs = 200/1000;
    rParams.temporalParams.stimulusDurationInSeconds = rParams.temporalParams.simulationTimeStepSecs;
    rParams.temporalParams.stimulusSamplingIntervalInSeconds = rParams.temporalParams.simulationTimeStepSecs;
    rParams.temporalParams.secondsToInclude = rParams.temporalParams.simulationTimeStepSecs;
    rParams.temporalParams.eyesDoNotMove = true;
    
    rParams.mosaicParams.timeStepInSeconds = rParams.temporalParams.simulationTimeStepSecs;
    rParams.mosaicParams.integrationTimeInSeconds = rParams.mosaicParams.timeStepInSeconds;
    rParams.mosaicParams.isomerizationNoise = true;
    rParams.mosaicParams.osNoise = true;
    rParams.mosaicParams.osModel = 'Linear';
end

%% Parameters that define the LM instances we'll generate here
%
% Make these numbers small (trialNum = 2, deltaAngle = 180,
% nContrastsPerDirection = 2) to run through a test quickly.
if (nargin < 2 | isempty(LMPlaneInstanceParams))
    LMPlaneInstanceParams = LMPlaneInstanceParamsGenerate;
end

%% Parameters related to how we find thresholds from responses
if (nargin < 3 | isempty(thresholdParams))
    thresholdParams = thresholdParamsGenerate;
end

%% Set up the rw object for this program
rwObject = IBIOColorDetectReadWriteBasic;
readProgram = 't_colorGaborConeCurrentEyeMovementsResponseInstancesOneFrame';
writeProgram = mfilename;

%% Read data for the no stimulus condition
fprintf('Reading no stimulus data ... ');
colorModulationParamsTemp = rParams.colorModulationParams;
colorModulationParamsTemp.coneContrasts = [0 0 0]';
colorModulationParamsTemp.contrast = 0;
parentParamsList = {rParams, LMPlaneInstanceParams, colorModulationParamsTemp};
noStimData = rwObject.read('responseInstances',parentParamsList,{},readProgram);
ancillaryData = rwObject.read('ancillaryData',parentParamsList,{},readProgram);

% Get out some data we'll want
nTrials = numel(noStimData.responseInstanceArray);
testConeContrasts = ancillaryData.testConeContrasts;
testContrasts = ancillaryData.testContrasts;

% If everything is working right, these check parameter structures will
% match what we used to specify the file we read in.
%
% SHOULD ACTUALLY CHECK FOR EQUALITY HERE.
rParamsCheck = ancillaryData.rParams; 
LMPlaneInstanceParamsCheck = ancillaryData.LMPlaneInstanceParams;
fprintf('done\n');

%% Put zero contrast response instances into data that we will pass to the SVM
%
% We can do this to simulate a one interval or a two interval task.  In the
% one interval task, the blanks and modulation instances are labelled as the
% two classes.  In the two inteval task, we concatenate [blank modulation]
% as one class and [modulation blank] as the other.  The same amount of
% data is used in each case, but the number of training instances is half
% for the two interval case, but with effective response vectors that are
% twice as long.
responseSize = numel(noStimData.responseInstanceArray(1).theMosaicPhotoCurrents(:));
fprintf('\nInserting null stimulus data from %d trials into design matrix ... ', nTrials);
if (thresholdParams.nIntervals == 1)
    data = zeros(2*nTrials, responseSize);
    classes = zeros(2*nTrials, 1);
    for iTrial = 1:nTrials
        if (strcmp(thresholdParams.signalSource,'photocurrents'))
            data(iTrial,:) = noStimData.responseInstanceArray(iTrial).theMosaicPhotoCurrents(:);
        else
            data(iTrial,:) = noStimData.responseInstanceArray(iTrial).theMosaicIsomerizations(:);
        end
        
        % Set up classes variable
        classes(iTrial,1) = 0;
        classes(nTrials+iTrial,1) = 1;
    end
elseif (thresholdParams.nIntervals == 2)
    data = zeros(nTrials, 2*responseSize);
    classes = zeros(nTrials, 1);
    for iTrial = 1:nTrials/2
        if (strcmp(thresholdParams.signalSource,'photocurrents'))
            data(iTrial,1:responseSize) = noStimData.responseInstanceArray(iTrial).theMosaicPhotoCurrents(:);
            data(nTrials/2+iTrial,responseSize+1:end) = noStimData.responseInstanceArray(nTrials/2+iTrial).theMosaicPhotoCurrents(:);
        else
            data(iTrial,1:responseSize) = noStimData.responseInstanceArray(iTrial).theMosaicIsomerizations(:);
            data(nTrials/2+iTrial,responseSize+1:end) = noStimData.responseInstanceArray(nTrials/2+iTrial).theMosaicIsomerizations(:);
        end
        
        % Set up classes variable
        classes(iTrial,1) = 0;
        classes(nTrials/2+iTrial,1) = 1;
    end
end
fprintf('done\n');

%% Do SVM for each test contrast and color direction.
%
% The work is done inside routine ClassifyForOneDirection.  We needed to
% encapsulate it there to make parfor happy.
%
% If you don't have a computer configured to work with parfor, you may need
% to change the parfor just to plain for.
tic
parforConditionStructs = responseGenerationParforConditionStructsGenerate(testConeContrasts,testContrasts);
nParforConditions = length(parforConditionStructs);
usePercentCorrect = cell(size(testConeContrasts,2),1);
useStdErr = cell(size(testConeContrasts,2),1);
parfor kk = 1:nParforConditions
    thisConditionStruct = parforConditionStructs{kk};
    colorModulationParamsTemp = rParams.colorModulationParams;
    colorModulationParamsTemp.coneContrasts = thisConditionStruct.testConeContrasts;
    colorModulationParamsTemp.contrast = thisConditionStruct.contrast;
    parentParamsList = {rParams, LMPlaneInstanceParams, colorModulationParamsTemp};
    stimData = rwObject.read('responseInstances',parentParamsList,{},readProgram);
    if (numel(stimData.responseInstanceArray) ~= nTrials)
        error('Inconsisent number of trials');
    end

    % Get performance for this instance
    [usePercentCorrect(kk),useStdErr(kk)] = ...
        ClassifyForOneDirection(stimData,data,classes,thresholdParams);  
end
fprintf('SVM classification took %2.2f minutes\n', toc/60);
clearvars('theData','useData','data');

% Take the returned vector form of the performance data and put it back into the
% matrix form we expect below and elsewhere.
for kk = 1:nParforConditions
    thisConditionStruct = parforConditionStructs{kk};
    performanceData.percentCorrect(thisConditionStruct.ii,thisConditionStruct.jj) = usePercent(kk);
    performanceData.stdErr(thisConditionStruct.ii,thisConditionStruct.jj) = useStdErr(kk);
end
performanceData.testConeContrasts = testConeContrasts;
performanceData.testContrasts = testContrasts;
performanceData.rParams = rParams;
performanceData.LMPlaneInstanceParams = LMPlaneInstanceParams;
performanceData.thresholdParams = thresholdParams;
clearvars('usePercentCorrect','useStdErr');

%% Save classification performance data and a copy of this script
fprintf('Writing performance data ... ');
parentParamsList = {rParams, LMPlaneInstanceParams};
currentParamsList = {thresholdParams};
rwObject.read('performanceData',performanceData,parentParamsList,currentParamsList,writeProgram);
fprintf('done\n');

%% Plot performances obtained.
hFig = figure(1); clf;
set(hFig, 'Position', [10 10 680 590], 'Color', [1 1 1]);
for ii = 1:size(testConeContrasts,2)
    subplot(size(testConeContrasts,2), 1, ii)
    errorbar(testContrasts, squeeze(percentCorrect(ii,:)), squeeze(stdErr(ii, :)), ...
        'ro-', 'LineWidth', 2.0, 'MarkerSize', 12, 'MarkerFaceColor', [1.0 0.5 0.50]);
    axis 'square'
    set(gca, 'YLim', [0 1.0],'XLim', [testContrasts(1) testContrasts(end)], 'FontSize', 14);
    xlabel('contrast', 'FontSize' ,16, 'FontWeight', 'bold');
    ylabel('percent correct', 'FontSize' ,16, 'FontWeight', 'bold');
    box off; grid on
    title(sprintf('LMS = [%2.2f %2.2f %2.2f]', testConeContrasts(1,ii), testConeContrasts(2,ii), testConeContrasts(3,ii)));
end

